Todo:
    - Make a DStore keep track of Clients, and log when they disconnect during communication.
    - Design Index.
    - Start developing operations
        - STORE
        - LOAD
        - REMOVEE
    - Timeouts on DStore and controller
        - How to handle timeouts on waiting for client request (dont want to disconect from client too soon)??

General Notes:
    - At Controller initialisation, create a thread that handles rebalancing - have it on a seperate thread basically
    - Make sure that when handling requests, at the end of the pattern matching for expectd token types, but an else for if the
    request was tokenized, but is not an expected token (e.g., LOAD send to Dstore).
    - Error handling needs to be cleaned up
        - Possible ErrorHandler class?
        - Currently just output details of error, not action being taken - need to also output the action being taken.
        - Fix?: create different types of exception for different types of error, pass them to error handler. error handler
        checks for type of exception and outputs the details of the error  and of the action taken as a result.
    - Currently, Client will stay active after the Controller disconnects - would be good to have the client be informed of when the 
    controller disconnects and then close.
        - Maybe implement heartbeat functionality between servers and clients

Errors:

Possible errors:
    - Not using the same port for a Dstore throughout it's life - this means that the messages sent to a Dstore will be on a different
    port to the one it initially joined on 
        - this may cause errors with the automated testing
        - can get around this by making the dstore send the initial request on it's server port or by manually passing in the original
        port number of the datastore whenever logging messages (would need to store it in a map also).
            - would also need to create the new socket whenever logging was done.
    - **FIXED** :If a Client or DStore cannot connect to the controller when they are created, they still carry on.
        - The process should stop if they can't connect to the controller as there is nothing they can do in this case.
        - **FIX** : Have made it so if they cant connect, they close. This was done by moving the startListening and waitForInput methods 
        into the try statement, so that if an exception is thrown (cant connect to controller), the objects do not start doing anything,
        and so execution stops
            - Essentially - added the setup and start stuff to a different method, and then only start listening for connections or user
            input if the setup is successful because the startListening/waitForInput methods are inside the "try" statements, and so won't 
            be called if an exception is thrown.
    - Currently, the system assumes the connection with the client will persist until they close it - should it be the case instead
    that a client is started for each request - i.e., should the ControllerClient channel remain open to handle further requests from the
    client, or will these further requests come from a different connection?
    - in ServerConnection, when calling the handleRequest method on the server, might need to run that on a new thread (enclose it in
    new Thread(() -> {}).start()) so that the server can be ready to serve another request as soon as possible. 
    - especially immportant for Dstore - Controller communication, as a single Dstore could be serving multiple rquests from the controller 
        at any one time.

Error Handling:
    - Tokenizing:
        - Request contains extra stuff after tokens
        - Request parameters are not of the correct structure 
            - filenames do not have '.<extension>'
            - provided folders for DStores are not of the correct
    - Controller:
        - Recieved connection is from neither a DStore or Client
    - DStore:
        - Main method - command line parameters are not of the correct form
        - When multiple Dstores join on the same port number
    - General:
        - Invalid responses for any request (i.e., tokenized to invalid request)
    
Extra Stuff:
    - Tokenize input on client side so that they cant send in requests they shouldnt be able to (e.g., invalid or like JOIN).
    - Heartbeat functionality between servers and clients - curretly just figure out connection is dead when can't read in on the stream.


GUI stuff:
    - Split DStore and Controller into DStore and DStoreTerminal, and Controller and ControllerTerminal (just like what was done for Client).
        - This will seperate the functionality of the controller away from it's presentation. 
        - DStoreTerminal and ControllerTerminal will end up just running the DStore and Controller classes in the terminal. Will then have a GUI
        one that runs them in a GUI form.

Tokens:
    - Store Operation:
        - STORE filename filesize
        - STORE_TO port1 port2 ... portR
        - ACK
        - STORE_ACK
        - STORE_COMPLETE
        - Error Handling:
            - ERROR_NOT_ENOUGH_DSTORES
            - ERROR_FILE_ALREADY_EXISTS

    - Load Operation:
        - LOAD filename
        - LOAD_FROM port filesize
        - LOAD_DATA filename
        - RELOAD filename
        - Error Handling:
            - ERROR_NOT_ENOUGH_DSTORES 
            - ERROR_FILE_DOES_NOT_EXIST
            - ERROR_LOAD
        
    - Remove Operation:
        - REMOVE filename
        - REMOVE_ACK filename
        - REMOVE_COMPLETE
        - Error Handling
            - ERROR_NOT_ENOUGH_DSTORES 
            - ERROR_FILE_DOES_NOT_EXIST
            - ERROR_FILE_DOES_NOT_EXIST filename
    
    - List Operaton:
        - LIST 
        - LIST file_list
        - ERROR_HANDLING:
            - ERROR_NOT_ENOUGH_DSTORES 

    - Storage Rebalance:
        - JOIN port
        - LIST
        - LIST file_list
        - REBALANCE files_to_send files_to_remove
        - REBALANCE_STORE filename filesize
        - ACK
        - REBALANCE_COMPLETE